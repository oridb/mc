use "systypes"

pkg sys =
	type scno 	= int64	/* syscall */
	type fdopt	= int64	/* fd options */
	type fd		= int32	/* fd */
	type pid	= int64	/* pid */
	type mprot	= int64	/* memory protection */
	type mopt	= int64	/* memory mapping options */
	type socktype	= int64	/* socket type */
	type sockopt	= int64	/* socket option */
	type sockproto	= int64	/* socket protocol */
	type sockfam	= uint8	/* socket family */
	type filemode	= uint16	/* file permission bits */
	type kflags	= uint16	/* kqueue flags */
	type whence	= int64
	type fcntlcmd	= int64
	type machport	= int32
	type signo	= int32
	type sigflags	= int32
	type ulockop	= uint32

	type fdset = struct
		bits	: int32[1024/4]
	;;

	type timespec = struct
		sec	: int64
		nsec	: int64
	;;

	type timeval = struct
		sec	: int64
		usec	: int32
	;;

	type timezone = struct
		minwest	: int32 /* of greenwich */
		dsttime	: int32	/* nonzero if DST applies */
	;;

	type clock = union
		`Clockrealtime
		`Clockmonotonic
	;;

	type sigset = uint32

	type sigaction = struct
		handler	: byte#	/* code pointer */
		mask	: sigset
		flags	: sigflags
	;;

	type waitstatus = union
		`Waitexit int32
		`Waitsig  int32
		`Waitstop int32
		`Waitfail int32
	;;

	type pollfd = struct
		fd	: fd
		events	: uint16
		revents	: uint16
	;;

	type statbuf = struct
		dev	: int32
		mode	: filemode
		nlink	: uint16
		ino	: uint64
		uid	: uint32
		gid	: uint32
		rdev	: uint32
		atime	: timespec
		mtime	: timespec
		ctime	: timespec
		birthtimespec	: timespec
		size	: off
		blocks	: int64
		blksize	: int32
		flags	: uint32
		gen	: uint32
		_spare	: uint32
		_qspare	: uint64[2]
	;;

	type rusage = struct
		utime	: timeval	/* user time */
		stime	: timeval	/* system time */
		_opaque	: uint64[14]	/* padding (darwin-specific data) */
	;;

	type utsname = struct
		system	: byte[256]
		node	: byte[256]
		release	: byte[256]
		version	: byte[256]
		machine	: byte[256]
	;;

	type sockaddr = struct
		len	: byte
		fam	: sockfam
		data	: byte[14] /* what is the *actual* length? */
	;;

	type sockaddr_in = struct
		len	: byte
		fam	: sockfam
		port	: uint16
		addr	: byte[4]
		zero	: byte[8]
	;;

	type sockaddr_in6 = struct
		len	: byte
		fam	: sockfam
		port	: uint16
		flowinf	: uint32
		addr	: byte[16]
		scope	: uint32
	;;

	type sockaddr_un = struct
		len	: uint8
		fam	: sockfam
		path	: byte[104]
	;;

	type sockaddr_storage = struct
		len	: byte
		fam	: sockfam
		__pad1	: byte[6]
		__align	: uint64
		__pad2	: byte[112]
	;;

	type dirent64 = struct
		ino	: uint64
		seekoff	: uint64	/* seek offset (optional, used by servers) */
		reclen	: uint16	/* length of this record */
		namlen	: uint16	/* length of string in d_name */
		typeid  : uint8		/* file type, see below */
		name	: byte[...]
	;;

	type kevent = struct
		ident	: intptr	/* identifier for this event */
		filter	: int16		/* filter for event */
		flags	: uint16	/* general flags */
		fflags	: uint32	/* filter-specific flags */
		data	: intptr	/* filter-specific data */
		udata	: byte#		/* opaque user data identifier */
	;;

	type kevent64 = struct
		ident	: uint64	/* identifier for this event */
		filter	: int16		/* filter for event */
		flags	: kflags	/* general flags */
		fflags	: uint32	/* filter-specific flags */
		data	: int64		/* filter-specific data */
		udata	: uint64	/* opaque user data identifier */
		ext	: uint64[2]	/* filter-specific extensions */
	;;

	const Seekset	: whence = 0
	const Seekcur	: whence = 1
	const Seekend	: whence = 2

	/* system specific constants */
	const Maxpathlen	: size = 1024

	/* fcntl constants */
	const Fdupfd		: fcntlcmd = 0		       /* duplicate file descriptor */
	const Fgetfd		: fcntlcmd = 1		       /* get file descriptor flags */
	const Fsetfd		: fcntlcmd = 2		       /* set file descriptor flags */
	const Fgetfl		: fcntlcmd = 3		       /* get file status flags */
	const Fsetfl		: fcntlcmd = 4		       /* set file status flags */
	const Fgetown		: fcntlcmd = 5		       /* get SIGIO/SIGURG proc/pgrp */
	const Fsetown		: fcntlcmd = 6		       /* set SIGIO/SIGURG proc/pgrp */
	const Fgetlk		: fcntlcmd = 7		       /* get record locking information */
	const Fsetlk		: fcntlcmd = 8		       /* set record locking information */
	const Fsetlkw		: fcntlcmd = 9		       /* F_SETLK; wait if blocked */
	const Fsetlkwtimeout	: fcntlcmd = 10			/* F_SETLK; wait if blocked, return on timeout */
	const Fflush_data	: fcntlcmd = 40
	const Fchkclean		: fcntlcmd = 41			/* Used for regression test */
	const Fpreallocate	: fcntlcmd = 42			/* Preallocate storage */
	const Fsetsize		: fcntlcmd = 43			/* Truncate a file without zeroing space */
	const Frdadvise		: fcntlcmd = 44			/* Issue an advisory read async with no copy to user */
	const Frdahead		: fcntlcmd = 45			/* turn read ahead off/on for this fd */
	/* 46,47 used to be F_READBOOTSTRAP and F_WRITEBOOTSTRAP */
	const Fnocache		: fcntlcmd = 48			/* turn data caching off/on for this fd */
	const Flog2phys		: fcntlcmd = 49			/* file offset to device offset */
	const Fgetpath		: fcntlcmd = 50			/* return the full path of the fd */
	const Ffullfsync	: fcntlcmd = 51			/* fsync + ask the drive to flush to the media */
	const Fpathpkg_check 	: fcntlcmd = 52			/* find which component (if any) is a package */
	const Ffreeze_fs	: fcntlcmd = 53			/* "freeze" all fs operations */
	const Fthaw_fs		: fcntlcmd = 54			/* "thaw" all fs operations */
	const Fglobal_nocache	: fcntlcmd = 55			/* turn data caching off/on (globally) for this file */
	const Faddsigs		: fcntlcmd = 59			/* add detached signatures */
	const Faddfilesigs	: fcntlcmd = 61			/* add signature from same file (used by dyld for shared libs) */
	const Fgetprotclass	: fcntlcmd = 63			/* Get the protection class of a file from the EA, returns int */
	const Fsetprotclass	: fcntlcmd = 64			/* Set the protection class of a file for the EA, requires int */
	const Flog2phys_ext	: fcntlcmd = 65			/* file offset to device offset, extended */
	const Fgetlkpid		: fcntlcmd = 66			/* get record locking information, per-process */
	/* See F_DUPFD_CLOEXEC below for 67 */
	const Fsetbacktore	: fcntlcmd = 70			/* Mark the file as being the backing store for another filesystem */
	const Fgetpath_mtminfo	: fcntlcmd = 71			/* return the full path of the FD, but error in specific mtmd circumstances */
	/* 72 is free.	It used to be F_GETENCRYPTEDDATA, which is now removed. */
	const Fsetnosigpipe	: fcntlcmd = 73			/* No SIGPIPE generated on EPIPE */
	const Fgetnosigpipe	: fcntlcmd = 74			/* Status of SIGPIPE for this fd */

	/* kqueue events */
	const Kevadd		: kflags = 0x0001	/* add event to kq (implies enable) */
	const Kevdelete		: kflags = 0x0002	/* delete event from kq */
	const Kevenable		: kflags = 0x0004	/* enable event */
	const Kevdisable	: kflags = 0x0008	/* disable event (not reported) */
	const Kevreceipt	: kflags = 0x0040	/* force EV_ERROR on success, data == 0 */

	/* kqueue flags */
	const Kevoneshot	: kflags = 0x0010	/* only report one occurrence */
	const Kevclear		: kflags = 0x0020	/* clear event state after reporting */
	const Kevdispatch	: kflags = 0x0080	/* disable event after reporting */

	const Kevsysflags	: kflags = 0xf000	/* reserved by system */
	const Kevflag0		: kflags = 0x1000	/* filter-specific flag */
	const Kevflag1		: kflags = 0x2000	/* filter-specific flag */

	/* kqueue returned values */
	const Keveof		: kflags = 0x8000	/* eof detected */
	const Keverror		: kflags = 0x4000	/* error, data contains errno */

	/* open options */
	const Ordonly  	: fdopt = 0x0
	const Owronly  	: fdopt = 0x1
	const Ordwr    	: fdopt = 0x2
	const Ondelay  	: fdopt = 0x4
	const Oappend  	: fdopt = 0x8
	const Ocreat   	: fdopt = 0x200
	const Onofollow	: fdopt = 0x100
	const Otrunc   	: fdopt = 0x400
	const Odir	: fdopt = 0x100000
	const Ocloexec	: fdopt = 0x1000000


	/* stat modes */
	const Sifmt	: filemode = 0xf000
	const Sififo	: filemode = 0x1000
	const Sifchr	: filemode = 0x2000
	const Sifdir	: filemode = 0x4000
	const Sifblk	: filemode = 0x6000
	const Sifreg	: filemode = 0x8000
	const Siflnk	: filemode = 0xa000
	const Sifsock	: filemode = 0xc000

	/* mmap protection */
	const Mprotnone	: mprot = 0x0
	const Mprotrd	: mprot = 0x1
	const Mprotwr	: mprot = 0x2
	const Mprotexec	: mprot = 0x4
	const Mprotrw	: mprot = 0x3

	/* mmap options */
	const Mshared	: mopt = 0x1
	const Mpriv	: mopt = 0x2
	const Mfixed	: mopt = 0x10
	const Mfile	: mopt = 0x0
	const Manon	: mopt = 0x1000
	/* Only on Linux
	const M32bit	: mopt = 0x40
	*/

	/* socket families. INCOMPLETE. */
	const Afunspec	: sockfam = 0
	const Afunix	: sockfam = 1
	const Afinet	: sockfam = 2
	const Afinet6	: sockfam = 30

	/* socket types. */
	const Sockstream	: socktype = 1
	const Sockdgram		: socktype = 2
	const Sockraw		: socktype = 3
	const Sockrdm		: socktype = 4
	const Sockseqpacket	: socktype = 5

	/* socket options */
	const Sodebug	: sockopt = 0x0001		/* turn on debugging info recording */
	const Soacceptconn	: sockopt = 0x0002	/* socket has had listen() */
	const Soreuseaddr	: sockopt = 0x0004	/* allow local address reuse */
	const Sokeepalive	: sockopt = 0x0008	/* keep connections alive */
	const Sodontroute	: sockopt = 0x0010	/* just use interface addresses */
	const Sobroadcast	: sockopt = 0x0020	/* permit sending of broadcast msgs */
	const Souseloopback	: sockopt = 0x0040	/* bypass hardware when possible */
	const Solingerticks	: sockopt = 0x0080	/* linger on close if data present (in ticks) */
	const Solingersecs	: sockopt = 0x1080	/* linger on close if data present (in seconds) */
	const Sooobinline	: sockopt = 0x0100	/* leave received OOB data in line */
	const Soreuseport	: sockopt = 0x0200	/* allow local address & port reuse */
	const Sotimestamp	: sockopt = 0x0400	/* timestamp received dgram traffic */
	const Somonotimestamp	: sockopt = 0x0800	/* Monotonically increasing timestamp on rcvd dgram */
	const Soacceptfilter	: sockopt = 0x1000	/* there is an accept filter */
	const Sodonttrunc	: sockopt = 0x2000	/* APPLE: Retain unread data */
	const Sowantmore	: sockopt = 0x4000	/* APPLE: Give hint when more data ready */
	const Sowantoobflag	: sockopt = 0x8000	/* APPLE: Want OOB in MSG_FLAG on receive */

	/* socket option levels */
	const Solsocket		: sockproto = 0xffff

	/* network protocols */
	const Ipproto_ip	: sockproto = 0
	const Ipproto_icmp	: sockproto = 1
	const Ipproto_tcp	: sockproto = 6
	const Ipproto_udp	: sockproto = 17
	const Ipproto_raw	: sockproto = 255

	/*
	* Requestable events.  If poll(2) finds any of these set, they are
	* copied to revents on return.
	*/
	const Pollin		: uint16 = 0x0001	/* any readable data available */
	const Pollpri		: uint16 = 0x0002	/* OOB/Urgent readable data */
	const Pollout		: uint16 = 0x0004	/* file descriptor is writeable */
	const Pollrdnorm	: uint16 = 0x0040	/* non-OOB/URG data available */
	const Pollwrnorm	: uint16 = Pollout	/* no write type differentiation */
	const Pollrdband	: uint16 = 0x0080	/* OOB/Urgent readable data */
	const Pollwrband	: uint16 = 0x0100	/* OOB/Urgent data can be written */

	/*
	* FreeBSD extensions: polling on a regular file might return one
	* of these events (currently only supported on local filesystems).
	*/
	const Pollextend	: uint16 = 0x0200	/* file may have been extended */
	const Pollattrib	: uint16 = 0x0400	/* file attributes may have changed */
	const Pollnlink		: uint16 = 0x0800	/* (un)link/rename may have happened */
	const Pollwrite		: uint16 = 0x1000	/* file's contents may have changed */

	/*
	* These events are set if they occur regardless of whether they were
	* requested.
	*/
	const Pollerr		: uint16 = 0x0008	/* some poll error occurred */
	const Pollhup		: uint16 = 0x0010	/* file descriptor was "hung up" */
	const Pollnval		: uint16 = 0x0020	/* requested events "invalid" */

	/* return value for a failed mapping */
	const Mapbad	: byte# = (-1 : byte#)

	/* signal actions */
	const Saonstack		: sigflags = 0x0001  /* take signal on signal stack */
	const Sarestart		: sigflags = 0x0002  /* restart system on signal return */
	const Saresethand	: sigflags = 0x0004  /* reset to SIG_DFL when taking signal */
	const Sanocldstop	: sigflags = 0x0008  /* do not generate SIGCHLD on child stop */
	const Sanodefer		: sigflags = 0x0010  /* don't mask the signal we're delivering */
	const Sanocldwait	: sigflags = 0x0020  /* don't keep zombies around */
	const Sasiginfo		: sigflags = 0x0040  /* signal handler with SA_SIGINFO args */

	/* signals */
	const Sighup	: signo = 1	/* hangup */
	const Sigint	: signo = 2	/* interrupt */
	const Sigquit	: signo = 3	/* quit */
	const Sigill	: signo = 4	/* illegal instruction (not reset when caught) */
	const Sigtrap	: signo = 5	/* trace trap (not reset when caught) */
	const Sigabrt	: signo = 6	/* abort() */
	const Sigiot	: signo = Sigabrt	/* compatibility */
	const Sigemt	: signo = 7	/* EMT instruction */
	const Sigfpe	: signo = 8	/* floating point exception */
	const Sigkill	: signo = 9	/* kill (cannot be caught or ignored) */
	const Sigbus	: signo = 10	/* bus error */
	const Sigsegv	: signo = 11	/* segmentation violation */
	const Sigsys	: signo = 12	/* bad argument to system call */
	const Sigpipe	: signo = 13	/* write on a pipe with no one to read it */
	const Sigalrm	: signo = 14	/* alarm clock */
	const Sigterm	: signo = 15	/* software termination signal from kill */
	const Sigurg	: signo = 16	/* urgent condition on IO channel */
	const Sigstop	: signo = 17	/* sendable stop signal not from tty */
	const Sigtstp	: signo = 18	/* stop signal from tty */
	const Sigcont	: signo = 19	/* continue a stopped process */
	const Sigchld	: signo = 20	/* to parent on child stop or exit */
	const Sigttin	: signo = 21	/* to readers pgrp upon background tty read */
	const Sigttou	: signo = 22	/* like TTIN for output if (tp->t_local&LTOSTOP) */
	const Sigio	: signo = 23	/* input/output possible signal */
	const Sigxcpu	: signo = 24	/* exceeded CPU time limit */
	const Sigxfsz	: signo = 25	/* exceeded file size limit */
	const Sigvtalrm : signo = 26	/* virtual time alarm */
	const Sigprof	: signo = 27	/* profiling time alarm */
	const Sigwinch	: signo = 28	/* window size changes */
	const Siginfo	: signo = 29	/* information request */
	const Sigusr1	: signo = 30	/* user defined signal 1 */
	const Sigusr2	: signo = 31	/* user defined signal 2 */

	/* ulock ops */
	const Ulockcompareandwait		: ulockop = 0x00000001
	const Ulockunfairlock			: ulockop = 0x00000002
	const Ulockulfwakeall			: ulockop = 0x00000100
	const Ulockulfwakethread		: ulockop = 0x00000200
	const Ulockwaitworkqdatacontention	: ulockop = 0x00010000
	const Ulocknoerrno			: ulockop = 0x01000000

	/* syscalls.
	note, creat() implemented as open(path, Creat|Trunc|Wronly) */
	const Syssyscall	: scno = 0x2000000
	const Sysexit		: scno = 0x2000001
	const Sysfork		: scno = 0x2000002
	const Sysread		: scno = 0x2000003
	const Syswrite		: scno = 0x2000004
	const Sysopen		: scno = 0x2000005
	const Sysclose		: scno = 0x2000006
	const Syswait4		: scno = 0x2000007
	const Syslink		: scno = 0x2000009
	const Sysunlink		: scno = 0x200000a
	const Syschdir		: scno = 0x200000c
	const Sysfchdir		: scno = 0x200000d
	const Sysmknod		: scno = 0x200000e
	const Syschmod		: scno = 0x200000f
	const Syschown		: scno = 0x2000010
	const Sysgetfsstat	: scno = 0x2000012
	const Sysgetpid		: scno = 0x2000014
	const Syssetuid		: scno = 0x2000017
	const Sysgetuid		: scno = 0x2000018
	const Sysgeteuid	: scno = 0x2000019
	const Sysptrace		: scno = 0x200001a
	const Sysrecvmsg	: scno = 0x200001b
	const Syssendmsg	: scno = 0x200001c
	const Sysrecvfrom	: scno = 0x200001d
	const Sysaccept		: scno = 0x200001e
	const Sysgetpeername	: scno = 0x200001f
	const Sysgetsockname	: scno = 0x2000020
	const Sysaccess		: scno = 0x2000021
	const Syschflags	: scno = 0x2000022
	const Sysfchflags	: scno = 0x2000023
	const Syssync		: scno = 0x2000024
	const Syskill		: scno = 0x2000025
	const Sysgetppid	: scno = 0x2000027
	const Sysdup		: scno = 0x2000029
	const Syspipe		: scno = 0x200002a
	const Sysgetegid	: scno = 0x200002b
	const Sysprofil		: scno = 0x200002c
	const Syssigaction	: scno = 0x200002e
	const Sysgetgid		: scno = 0x200002f
	const Syssigprocmask	: scno = 0x2000030
	const Sysgetlogin	: scno = 0x2000031
	const Syssetlogin	: scno = 0x2000032
	const Sysacct		: scno = 0x2000033
	const Syssigpending	: scno = 0x2000034
	const Syssigaltstack	: scno = 0x2000035
	const Sysioctl		: scno = 0x2000036
	const Sysreboot		: scno = 0x2000037
	const Sysrevoke		: scno = 0x2000038
	const Syssymlink	: scno = 0x2000039
	const Sysreadlink	: scno = 0x200003a
	const Sysexecve		: scno = 0x200003b
	const Sysumask		: scno = 0x200003c
	const Syschroot		: scno = 0x200003d
	const Sysmsync		: scno = 0x2000041
	const Sysvfork		: scno = 0x2000042
	const Sysmunmap		: scno = 0x2000049
	const Sysmprotect	: scno = 0x200004a
	const Sysmadvise	: scno = 0x200004b
	const Sysmincore	: scno = 0x200004e
	const Sysgetgroups	: scno = 0x200004f
	const Syssetgroups	: scno = 0x2000050
	const Sysgetpgrp	: scno = 0x2000051
	const Syssetpgid	: scno = 0x2000052
	const Syssetitimer	: scno = 0x2000053
	const Sysswapon		: scno = 0x2000055
	const Sysgetitimer	: scno = 0x2000056
	const Sysgetdtablesize	: scno = 0x2000059
	const Sysdup2		: scno = 0x200005a
	const Sysfcntl		: scno = 0x200005c
	const Sysselect		: scno = 0x200005d
	const Sysfsync		: scno = 0x200005f
	const Syssetpriority	: scno = 0x2000060
	const Syssocket		: scno = 0x2000061
	const Sysconnect	: scno = 0x2000062
	const Sysgetpriority	: scno = 0x2000064
	const Sysbind		: scno = 0x2000068
	const Syssetsockopt	: scno = 0x2000069
	const Syslisten		: scno = 0x200006a
	const Syssigsuspend	: scno = 0x200006f
	const Sysgettimeofday	: scno = 0x2000074
	const Sysgetrusage	: scno = 0x2000075
	const Sysgetsockopt	: scno = 0x2000076
	const Sysreadv		: scno = 0x2000078
	const Syswritev		: scno = 0x2000079
	const Syssettimeofday	: scno = 0x200007a
	const Sysfchown		: scno = 0x200007b
	const Sysfchmod		: scno = 0x200007c
	const Syssetreuid	: scno = 0x200007e
	const Syssetregid	: scno = 0x200007f
	const Sysrename		: scno = 0x2000080
	const Sysflock		: scno = 0x2000083
	const Sysmkfifo		: scno = 0x2000084
	const Syssendto		: scno = 0x2000085
	const Sysshutdown	: scno = 0x2000086
	const Syssocketpair	: scno = 0x2000087
	const Sysmkdir		: scno = 0x2000088
	const Sysrmdir		: scno = 0x2000089
	const Sysutimes		: scno = 0x200008a
	const Sysfutimes	: scno = 0x200008b
	const Sysadjtime	: scno = 0x200008c
	const Sysgethostuuid	: scno = 0x200008e
	const Syssetsid		: scno = 0x2000093
	const Sysgetpgid	: scno = 0x2000097
	const Syssetprivexec	: scno = 0x2000098
	const Syspread		: scno = 0x2000099
	const Syspwrite		: scno = 0x200009a
	const Sysnfssvc		: scno = 0x200009b
	const Sysstatfs		: scno = 0x200009d
	const Sysfstatfs	: scno = 0x200009e
	const Sysunmount	: scno = 0x200009f
	const Sysgetfh		: scno = 0x20000a1
	const Sysquotactl	: scno = 0x20000a5
	const Sysmount		: scno = 0x20000a7
	const Syscsops		: scno = 0x20000a9
	const Syswaitid		: scno = 0x20000ad
	const Sysadd_profil	: scno = 0x20000b0
	const Syskdebug_trace	: scno = 0x20000b4
	const Syssetgid		: scno = 0x20000b5
	const Syssetegid	: scno = 0x20000b6
	const Sysseteuid	: scno = 0x20000b7
	const Syssigreturn	: scno = 0x20000b8
	const Syschud		: scno = 0x20000b9
	const Sysfdatasync	: scno = 0x20000bb
	const Sysstat		: scno = 0x20000bc
	const Sysfstat		: scno = 0x20000bd
	const Syslstat		: scno = 0x20000be
	const Syspathconf	: scno = 0x20000bf
	const Sysfpathconf	: scno = 0x20000c0
	const Sysgetrlimit	: scno = 0x20000c2
	const Syssetrlimit	: scno = 0x20000c3
	const Sysgetdirentries	: scno = 0x20000c4
	const Sysmmap		: scno = 0x20000c5
	const Syslseek		: scno = 0x20000c7
	const Systruncate	: scno = 0x20000c8
	const Sysftruncate	: scno = 0x20000c9
	const Sys__sysctl	: scno = 0x20000ca
	const Sysmlock		: scno = 0x20000cb
	const Sysmunlock	: scno = 0x20000cc
	const Sysundelete	: scno = 0x20000cd
	const SysATsocket	: scno = 0x20000ce
	const SysATgetmsg	: scno = 0x20000cf
	const SysATputmsg	: scno = 0x20000d0
	const SysATPsndreq	: scno = 0x20000d1
	const SysATPsndrsp	: scno = 0x20000d2
	const SysATPgetreq	: scno = 0x20000d3
	const SysATPgetrsp	: scno = 0x20000d4
	const Sysmkcomplex	: scno = 0x20000d8
	const Sysstatv		: scno = 0x20000d9
	const Syslstatv		: scno = 0x20000da
	const Sysfstatv		: scno = 0x20000db
	const Sysgetattrlist	: scno = 0x20000dc
	const Syssetattrlist	: scno = 0x20000dd
	const Sysgetdirentriesattr	: scno = 0x20000de
	const Sysexchangedata	: scno = 0x20000df
	const Syssearchfs	: scno = 0x20000e1
	const Sysdelete		: scno = 0x20000e2
	const Syscopyfile	: scno = 0x20000e3
	const Sysfgetattrlist	: scno = 0x20000e4
	const Sysfsetattrlist	: scno = 0x20000e5
	const Syspoll		: scno = 0x20000e6
	const Syswatchevent	: scno = 0x20000e7
	const Syswaitevent	: scno = 0x20000e8
	const Sysmodwatch	: scno = 0x20000e9
	const Sysgetxattr	: scno = 0x20000ea
	const Sysfgetxattr	: scno = 0x20000eb
	const Syssetxattr	: scno = 0x20000ec
	const Sysfsetxattr	: scno = 0x20000ed
	const Sysremovexattr	: scno = 0x20000ee
	const Sysfremovexattr	: scno = 0x20000ef
	const Syslistxattr	: scno = 0x20000f0
	const Sysflistxattr	: scno = 0x20000f1
	const Sysfsctl		: scno = 0x20000f2
	const Sysinitgroups	: scno = 0x20000f3
	const Sysposix_spawn	: scno = 0x20000f4
	const Sysffsctl		: scno = 0x20000f5
	const Sysnfsclnt	: scno = 0x20000f7
	const Sysfhopen		: scno = 0x20000f8
	const Sysminherit	: scno = 0x20000fa
	const Syssemsys		: scno = 0x20000fb
	const Sysmsgsys		: scno = 0x20000fc
	const Sysshmsys		: scno = 0x20000fd
	const Syssemctl		: scno = 0x20000fe
	const Syssemget		: scno = 0x20000ff
	const Syssemop		: scno = 0x2000100
	const Sysmsgctl		: scno = 0x2000102
	const Sysmsgget		: scno = 0x2000103
	const Sysmsgsnd		: scno = 0x2000104
	const Sysmsgrcv		: scno = 0x2000105
	const Sysshmat		: scno = 0x2000106
	const Sysshmctl		: scno = 0x2000107
	const Sysshmdt		: scno = 0x2000108
	const Sysshmget		: scno = 0x2000109
	const Sysshm_open	: scno = 0x200010a
	const Sysshm_unlink	: scno = 0x200010b
	const Syssem_open	: scno = 0x200010c
	const Syssem_close	: scno = 0x200010d
	const Syssem_unlink	: scno = 0x200010e
	const Syssem_wait	: scno = 0x200010f
	const Syssem_trywait	: scno = 0x2000110
	const Syssem_post	: scno = 0x2000111
	const Syssem_getvalue	: scno = 0x2000112
	const Syssem_init	: scno = 0x2000113
	const Syssem_destroy	: scno = 0x2000114
	const Sysopen_extended	: scno = 0x2000115
	const Sysumask_extended	: scno = 0x2000116
	const Sysstat_extended	: scno = 0x2000117
	const Syslstat_extended	: scno = 0x2000118
	const Sysfstat_extended	: scno = 0x2000119
	const Syschmod_extended	: scno = 0x200011a
	const Sysfchmod_extended	: scno = 0x200011b
	const Sysaccess_extended	: scno = 0x200011c
	const Syssettid		: scno = 0x200011d
	const Sysgettid		: scno = 0x200011e
	const Syssetsgroups	: scno = 0x200011f
	const Sysgetsgroups	: scno = 0x2000120
	const Syssetwgroups	: scno = 0x2000121
	const Sysgetwgroups	: scno = 0x2000122
	const Sysmkfifo_extended	: scno = 0x2000123
	const Sysmkdir_extended	: scno = 0x2000124
	const Sysidentitysvc	: scno = 0x2000125
	const Sysshared_region_check_np	: scno = 0x2000126
	const Sysshared_region_map_np	: scno = 0x2000127
	const Sysvm_pressure_monitor	: scno = 0x2000128
	const Syspsynch_rw_longrdlock	: scno = 0x2000129
	const Syspsynch_rw_yieldwrlock	: scno = 0x200012a
	const Syspsynch_rw_downgrade	: scno = 0x200012b
	const Syspsynch_rw_upgrade	: scno = 0x200012c
	const Syspsynch_mutexwait	: scno = 0x200012d
	const Syspsynch_mutexdrop	: scno = 0x200012e
	const Syspsynch_cvbroad	: scno = 0x200012f
	const Syspsynch_cvsignal	: scno = 0x2000130
	const Syspsynch_cvwait	: scno = 0x2000131
	const Syspsynch_rw_rdlock	: scno = 0x2000132
	const Syspsynch_rw_wrlock	: scno = 0x2000133
	const Syspsynch_rw_unlock	: scno = 0x2000134
	const Syspsynch_rw_unlock2	: scno = 0x2000135
	const Sysgetsid		: scno = 0x2000136
	const Syssettid_with_pid	: scno = 0x2000137
	const Sysaio_fsync	: scno = 0x2000139
	const Sysaio_return	: scno = 0x200013a
	const Sysaio_suspend	: scno = 0x200013b
	const Sysaio_cancel	: scno = 0x200013c
	const Sysaio_error	: scno = 0x200013d
	const Sysaio_read	: scno = 0x200013e
	const Sysaio_write	: scno = 0x200013f
	const Syslio_listio	: scno = 0x2000140
	const Sysiopolicysys	: scno = 0x2000142
	const Sysmlockall	: scno = 0x2000144
	const Sysmunlockall	: scno = 0x2000145
	const Sysissetugid	: scno = 0x2000147
	const Sys__pthread_kill	: scno = 0x2000148
	const Sys__pthread_sigmask	: scno = 0x2000149
	const Sys__sigwait	: scno = 0x200014a
	const Sys__disable_threadsignal	: scno = 0x200014b
	const Sys__pthread_markcancel	: scno = 0x200014c
	const Sys__pthread_canceled	: scno = 0x200014d
	const Sys__semwait_signal	: scno = 0x200014e
	const Sysproc_info	: scno = 0x2000150
	const Syssendfile	: scno = 0x2000151
	const Sysstat64		: scno = 0x2000152
	const Sysfstat64	: scno = 0x2000153
	const Syslstat64	: scno = 0x2000154
	const Sysstat64_extended	: scno = 0x2000155
	const Syslstat64_extended	: scno = 0x2000156
	const Sysfstat64_extended	: scno = 0x2000157
	const Sysgetdirentries64	: scno = 0x2000158
	const Sysstatfs64	: scno = 0x2000159
	const Sysfstatfs64	: scno = 0x200015a
	const Sysgetfsstat64	: scno = 0x200015b
	const Sys__pthread_chdir	: scno = 0x200015c
	const Sys__pthread_fchdir	: scno = 0x200015d
	const Sysaudit		: scno = 0x200015e
	const Sysauditon	: scno = 0x200015f
	const Sysgetauid	: scno = 0x2000161
	const Syssetauid	: scno = 0x2000162
	const Sysgetaudit	: scno = 0x2000163
	const Syssetaudit	: scno = 0x2000164
	const Sysgetaudit_addr	: scno = 0x2000165
	const Syssetaudit_addr	: scno = 0x2000166
	const Sysauditctl	: scno = 0x2000167
	const Sysbsdthread_create	: scno = 0x2000168
	const Sysbsdthread_terminate	: scno = 0x2000169
	const Syskqueue		: scno = 0x200016a
	const Syskevent		: scno = 0x200016b
	const Syslchown		: scno = 0x200016c
	const Sysstack_snapshot	: scno = 0x200016d
	const Sysbsdthread_register	: scno = 0x200016e
	const Sysworkq_open	: scno = 0x200016f
	const Sysworkq_kernreturn	: scno = 0x2000170
	const Syskevent64	: scno = 0x2000171
	const Sys__old_semwait_signal	: scno = 0x2000172
	const Sys__old_semwait_signal_nocancel	: scno = 0x2000173
	const Systhread_selfid	: scno = 0x2000174
	const Sys__mac_execve	: scno = 0x200017c
	const Sys__mac_syscall	: scno = 0x200017d
	const Sys__mac_get_file	: scno = 0x200017e
	const Sys__mac_set_file	: scno = 0x200017f
	const Sys__mac_get_link	: scno = 0x2000180
	const Sys__mac_set_link	: scno = 0x2000181
	const Sys__mac_get_proc	: scno = 0x2000182
	const Sys__mac_set_proc	: scno = 0x2000183
	const Sys__mac_get_fd	: scno = 0x2000184
	const Sys__mac_set_fd	: scno = 0x2000185
	const Sys__mac_get_pid	: scno = 0x2000186
	const Sys__mac_get_lcid	: scno = 0x2000187
	const Sys__mac_get_lctx	: scno = 0x2000188
	const Sys__mac_set_lctx	: scno = 0x2000189
	const Syssetlcid	: scno = 0x200018a
	const Sysgetlcid	: scno = 0x200018b
	const Sysread_nocancel	: scno = 0x200018c
	const Syswrite_nocancel	: scno = 0x200018d
	const Sysopen_nocancel	: scno = 0x200018e
	const Sysclose_nocancel	: scno = 0x200018f
	const Syswait4_nocancel	: scno = 0x2000190
	const Sysrecvmsg_nocancel	: scno = 0x2000191
	const Syssendmsg_nocancel	: scno = 0x2000192
	const Sysrecvfrom_nocancel	: scno = 0x2000193
	const Sysaccept_nocancel	: scno = 0x2000194
	const Sysmsync_nocancel		: scno = 0x2000195
	const Sysfcntl_nocancel		: scno = 0x2000196
	const Sysselect_nocancel	: scno = 0x2000197
	const Sysfsync_nocancel		: scno = 0x2000198
	const Sysconnect_nocancel	: scno = 0x2000199
	const Syssigsuspend_nocancel	: scno = 0x200019a
	const Sysreadv_nocancel		: scno = 0x200019b
	const Syswritev_nocancel	: scno = 0x200019c
	const Syssendto_nocancel	: scno = 0x200019d
	const Syspread_nocancel		: scno = 0x200019e
	const Syspwrite_nocancel	: scno = 0x200019f
	const Syswaitid_nocancel	: scno = 0x20001a0
	const Syspoll_nocancel		: scno = 0x20001a1
	const Sysmsgsnd_nocancel	: scno = 0x20001a2
	const Sysmsgrcv_nocancel	: scno = 0x20001a3
	const Syssem_wait_nocancel	: scno = 0x20001a4
	const Sysaio_suspend_nocancel	: scno = 0x20001a5
	const Sys__sigwait_nocancel	: scno = 0x20001a6
	const Sys__semwait_signal_nocancel	: scno = 0x20001a7
	const Sys__mac_mount		: scno = 0x20001a8
	const Sys__mac_get_mount	: scno = 0x20001a9
	const Sys__mac_getfsstat	: scno = 0x20001aa
	const Sysfsgetpath		: scno = 0x20001ab
	const Sysaudit_session_self	: scno = 0x20001ac
	const Sysaudit_session_join	: scno = 0x20001ad
	const Syspid_suspend		: scno = 0x20001ae
	const Syspid_resume		: scno = 0x20001af
	const Sysfileport_makeport	: scno = 0x20001b0
	const Sysfileport_makefd	: scno = 0x20001b1
	const Sysulock_wait		: scno = 0x2000203
	const Sysulock_wake		: scno = 0x2000204

	extern const syscall : (sc:scno, args:... -> int64)

	/* process control */
	const exit	: (status:int -> void)
	const getpid	: ( -> pid)
	const kill	: (pid : pid, sig:int64 -> int64)
	const fork	: (-> pid)
	const wait4	: (pid : pid, loc:int32#, opt : int64, rusage:rusage#	-> int64)
	const waitpid	: (pid : pid, loc:int32#, opt : int64	-> int64)
	const execv	: (cmd : byte[:], args : byte[:][:] -> int64)
	const execve	: (cmd : byte[:], args : byte[:][:], env : byte[:][:] -> int64)
	/* wrappers to extract wait status */
	const waitstatus	: (st : int32 -> waitstatus)
	const bsdthread_register	: (start : void#, wqthread : void#, sz : uint32, dummy : uint32, targetconc : void#, queueoff : uint32 -> int)
	const bsdthread_create	: (func : void#, arg : void#, stk : void#, pthr : void#, flags : uint32 -> void#)
	const bsdthread_terminate	: (stk : void#, len : size, port : machport, sem : machport -> int)

	/* file manipulation */
	const open	: (path:byte[:], opts:fdopt -> fd)
	const openmode	: (path:byte[:], opts:fdopt, mode:int64 -> fd)
	const close	: (fd:fd -> int64)
	const rename	: (from : byte[:], to : byte[:] -> int64)
	const creat	: (path:byte[:], mode:int64 -> fd)
	const unlink	: (path:byte[:] -> int)
	const rmdir	: (path:byte# -> int)
	const read	: (fd:fd, buf:byte[:] -> size)
	const pread	: (fd:fd, buf:byte[:], off : off -> size)
	const write	: (fd:fd, buf:byte[:] -> size)
	const pwrite	: (fd:fd, buf:byte[:], off : off -> size)
	const lseek	: (fd:fd, off:off, whence:whence -> off)
	const stat	: (path:byte[:], sb:statbuf# -> int64)
	const lstat	: (path:byte[:], sb:statbuf# -> int64)
	const fstat	: (fd:fd, sb:statbuf# -> int64)
	const mkdir	: (path : byte[:], mode : int64	-> int64)
	generic ioctl	: (fd:fd, req : int64, args:@a# -> int64)
	const getdirentries64	: (fd : fd, buf : byte[:], basep : int64# -> int64)
	const chdir	: (p : byte[:] -> int64)

	/* signals */
	const sigaction	: (sig : signo, act : sigaction#, oact : sigaction# -> int)
	const sigprocmask	: (how : int32, set : sigset#, oset : sigset# -> int)

	/* fd stuff */
	const pipe	: (fd : fd[2]# -> int64)
	const dup	: (fd : fd -> fd)
	const dup2	: (src : fd, dst : fd -> fd)
	/* NB: the C ABI uses '...' for the args. */
	const fcntl	: (fd : fd, cmd : fcntlcmd, args : byte# -> int64)
	const poll	: (pfd : pollfd[:], tm : int -> int)
	const select	: (nfd : int32, readfd : fdset#, writefd : fdset#, errfd : fdset#, tm : timeval# -> int32)

	/* kqueue */
	const kqueue	: (-> fd)
	const kevent	: (q : fd, cl : kevent[:], el : kevent[:], flg : kflags, timeout : timespec# -> int64)
	const kevent64	: (q : fd, cl : kevent64[:], el : kevent64[:], flg : kflags, timeout : timespec# -> int64)

	/* networking */
	const socket	: (dom : sockfam, stype : socktype, proto : sockproto	-> fd)
	const connect	: (sock	: fd, addr : sockaddr#, len : size -> int)
	const accept	: (sock : fd, addr : sockaddr#, len : size# -> fd)
	const listen	: (sock : fd, backlog : int	-> int)
	const bind	: (sock : fd, addr : sockaddr#, len : size -> int)
	const setsockopt	: (sock : fd, lev : sockproto, opt : sockopt, val : void#, len : size -> int)
	const getsockopt	: (sock : fd, lev : sockproto, opt : sockopt, val : void#, len : size# -> int)

	/* memory mapping */
	const munmap	: (addr:byte#, len:size -> int64)
	const mmap	: (addr:byte#, len:size, prot:mprot, flags:mopt, fd:fd, off:off -> byte#)

	/* time */
	const gettimeofday	: (tv : timeval#, tz : timezone# -> int)
	const settimeofday	: (tv : timeval#, tz : timezone# -> int)
	/* faked with gettimeofday */
	const clock_getres	: (clk : clock, ts : timespec# -> int)
	const clock_gettime	: (clk : clock, ts : timespec# -> int)
	const clock_settime	: (clk : clock, ts : timespec# -> int)
	const sleep	: (time : uint64 -> int32)

	/* system information */
	const uname 	: (buf : utsname# -> int)
	const sysctl	: (mib : int[:], \
		old : void#, oldsz : size#, \
		new : void#, newsz : size# \
		-> int)

	/* ulock */
	const ulock_wait	: (op : ulockop, uaddr : void#, val : uint64, timeout : uint32 -> int)
	const ulock_wake	: (op : ulockop, uaddr : void#, wakeval : uint64 -> int)

	extern const cstring : (str : byte[:] -> byte#)
	/* filled by start code */
	extern var __cenvp : byte##
;;

/*
wraps a syscall argument, converting it to 64 bits for the syscall function. This is
the same as casting, but more concise than writing a cast to uint64
*/
generic a = {x : @t
	-> (x : uint64)
}

/* OSX has a number of funky syscalls */
extern const __osx_fork	: (-> pid)
extern const __osx_pipe : (fd : fd[2]# -> int64)
extern const __osx_getpid	: (-> pid)
extern const __osx_lseek	: (fd:fd, off:off, whence:whence -> off)
extern const __osx_gettimeofday	: (tv : timeval#, tz : timezone#, abstime : uint64# -> int)
/*
extern const __osx_ptrace
extern const __osx_signalstack
extern const __osx_sigreturn
extern const __osx_thread_selfid
extern const __osx_vfork
*/

extern const alloca : (sz : size -> byte#)

/* process control */
const exit	= {status;		syscall(Sysexit, a(status))}
const getpid	= {;			-> (syscall(Sysgetpid) : pid)}
const kill	= {pid, sig;		-> syscall(Syskill, a(pid), a(sig))}
const fork	= {;			-> __osx_fork()}
const wait4	= {pid, loc, opt, rusage;	-> syscall(Syswait4, a(pid), a(loc), a(opt), a(rusage))}
const waitpid	= {pid, loc, opt;
	-> wait4(pid, loc, opt, (0 : rusage#))
}

const bsdthread_register = {start, wqthread, sz, dummy, targetconc, queueoff
	-> (syscall(Sysbsdthread_register, \
		a(start), \
		a(wqthread), \
		a(sz), \
		a(dummy), \
		a(targetconc), \
		a(queueoff)) : int)
}

const bsdthread_create	= {func , arg , stk , pthr , flags
	-> (syscall(Sysbsdthread_create, a(func), a(arg), a(stk), a(pthr), a(flags)) : void#)
}

const bsdthread_terminate	= {stk , len , port , sem
	-> (syscall(Sysbsdthread_terminate, a(stk), a(len), a(port), a(sem)) : int)
}

const sleep = {time
	-> sys.select( \
		0, \
		(0 : sys.fdset#), \
		(0 : sys.fdset#), \
		(0 : sys.fdset#), \
		&[.sec = (time : int64), .usec = 0] \
	)
}

const execv	= {cmd, args
	var p, cargs, i

	/* doesn't just call execve() for efficiency's sake. */
	p = alloca((args.len + 1)*sizeof(byte#))
	cargs = (p : byte##)[:args.len + 1]
	for i = 0; i < args.len; i++
		cargs[i] = cstring(args[i])
	;;
	cargs[args.len] = (0 : byte#)
	-> syscall(Sysexecve, cstring(cmd), a(p), a(__cenvp))
}

const execve	= {cmd, args, env
	var cargs, cenv, i
	var p

	/* copy the args */
	p = alloca((args.len + 1)*sizeof(byte#))
	cargs = (p : byte##)[:args.len + 1]
	for i = 0; i < args.len; i++
		cargs[i] = cstring(args[i])
	;;
	cargs[args.len] = (0 : byte#)

	/*
	 copy the env.
	 of course we fucking have to duplicate this code everywhere,
	 since we want to stack allocate...
	*/
	p = alloca((env.len + 1)*sizeof(byte#))
	cenv = (p : byte##)[:env.len]
	for i = 0; i < env.len; i++
		cenv[i] = cstring(env[i])
	;;
	cenv[env.len] = (0 : byte#)

	-> syscall(Sysexecve, cstring(cmd), a(p), a(cenv))
}


/* fd manipulation */
const open	= {path, opts;		-> (syscall(Sysopen, cstring(path), a(opts), a(0o777)) : fd)}
const openmode	= {path, opts, mode;	-> (syscall(Sysopen, cstring(path), a(opts), a(mode)) : fd)}
const close	= {fd;			-> syscall(Sysclose, a(fd))}
const rename	= {from, to;		-> syscall(Sysrename, cstring(from), cstring(to))}
const creat	= {path, mode;		-> (openmode(path, Ocreat | Otrunc | Owronly, mode) : fd)}
const unlink	= {path;		-> (syscall(Sysunlink, cstring(path)) : int)}
const rmdir	= {path;		-> (syscall(Sysunlink, a(path)) : int)}
const read	= {fd, buf;		-> (syscall(Sysread, a(fd), (buf : byte#), a(buf.len)) : size)}
const pread	= {fd, buf, off;	-> (syscall(Syspread, a(fd), (buf : byte#), a(buf.len), a(off)) : size)}
const write	= {fd, buf;		-> (syscall(Syswrite, a(fd), (buf : byte#), a(buf.len)) : size)}
const pwrite	= {fd, buf, off;	-> (syscall(Syspwrite, a(fd), (buf : byte#), a(buf.len), a(off)) : size)}
const lseek	= {fd, off, whence;	-> __osx_lseek(fd, off, whence)}
const stat	= {path, sb;		-> syscall(Sysstat64, cstring(path), a(sb))}
const lstat	= {path, sb;		-> syscall(Syslstat64, cstring(path), a(sb))}
const fstat	= {fd, sb;		-> syscall(Sysfstat64, a(fd), a(sb))}
const mkdir	= {path, mode;		-> (syscall(Sysmkdir, cstring(path), a(mode)) : int64)}
generic ioctl	= {fd, req, arg;	-> (syscall(Sysioctl, a(fd), a(req), a(arg)) : int64)}
const getdirentries64	= {fd, buf, basep;	-> syscall(Sysgetdirentries64, a(fd), (buf : byte#), a(buf.len), a(basep))}
const chdir	= {dir;	-> syscall(Syschdir, cstring(dir))}

/* signals */
const sigaction	= {sig, act, oact;	-> (syscall(Syssigaction, a(sig), a(act), a(oact)) : int)}
const sigprocmask	= {sig, act, oact;	-> (syscall(Syssigprocmask, a(sig), a(act), a(oact)) : int)}

/* fd stuff */
const pipe	= {fd;	-> __osx_pipe(fd)}
const dup 	= {fd;	-> (syscall(Sysdup, a(fd)) : fd)}
const dup2 	= {src, dst;	-> (syscall(Sysdup2, a(src), a(dst)) : fd)}
const fcntl	= {fd, cmd, args; 	-> syscall(Sysfcntl, a(fd), a(cmd), a(args))}
const poll	= {pfd, tm;	-> (syscall(Syspoll, (pfd : byte#), a(pfd.len), a(tm)) : int)}
const select	= {nfd, readfd, writefd, errfd, tm; -> (syscall(Sysselect, a(nfd), a(readfd), a(writefd), a(errfd), a(tm)) : int32)}

/* kqueueueueueueue */
const kqueue	= {;	-> (syscall(Syskqueue) : fd)}
const kevent	= {q, cl, el, flg, timeout
	-> syscall(Syskevent, a(q), \
		(cl : kevent#), a(cl.len), \
		(el : kevent#), a(el.len), \
		a(flg), \
		timeout)
}

const kevent64	= {q, cl, el, flg, timeout
	-> syscall(Syskevent, a(q), \
		(cl : kevent#), a(cl.len), \
		(el : kevent#), a(el.len), \
		a(flg), \
		timeout)
}

/* networking */
const socket	= {dom, stype, proto;	-> (syscall(Syssocket, a(dom), a(stype), a(proto)) : fd)}
const connect	= {sock, addr, len;	-> (syscall(Sysconnect, a(sock), a(addr), a(len)) : int)}
const accept	= {sock, addr, len;	-> (syscall(Sysaccept, a(sock), a(addr), a(len)) : fd)}
const listen	= {sock, backlog;	-> (syscall(Syslisten, a(sock), a(backlog)) : int)}
const bind	= {sock, addr, len;	-> (syscall(Sysbind, a(sock), a(addr), a(len)) : int)}
const setsockopt	= {sock, lev, opt, val, len;	-> (syscall(Syssetsockopt, a(sock), a(lev), a(opt), a(val), a(len)) : int)}
const getsockopt	= {sock, lev, opt, val, len;	-> (syscall(Syssetsockopt, a(sock), a(lev), a(opt), a(val), a(len)) : int)}

/* memory management */
const munmap	= {addr, len;		-> syscall(Sysmunmap, a(addr), a(len))}
const mmap	= {addr, len, prot, flags, fd, off;
	-> (syscall(Sysmmap, a(addr), a(len), a(prot), a(flags), a(fd), a(off)) : byte#)}

/* time */
const gettimeofday = {tv, tz;	-> (__osx_gettimeofday(tv, tz, (0 : uint64#)) : int)}
const settimeofday = {tv, tz;	-> (syscall(Syssettimeofday, a(tv), a(tz)) : int)}

/* faked  with gettimeofday */
const clock_getres = {clk, ts
	ts.sec = 0
	ts.nsec = 1000*10 /* 10ms is reasonable resolution */
	-> 0
}

const clock_gettime = {clk, ts
	var tv
	var ret

	ret = gettimeofday(&tv, (0 : timezone#))
	ts.sec = tv.sec
	ts.nsec = (tv.usec * 1000 : int64)
	-> ret
}

const clock_settime = {clk, ts
	var tv

	tv.sec = ts.sec
	tv.usec = (ts.nsec / 1000 : int32)
	-> settimeofday(&tv, (0 : timezone#))
}

/* system information */
const uname	= {buf;
	var mib : int[2]
	var ret
	var sys, syssz
	var nod, nodsz
	var rel, relsz
	var ver, versz
	var mach, machsz

	ret = 0
	mib[0] = 1 /* CTL_KERN */
	mib[1] = 1 /* KERN_OSTYPE */
	sys = (buf.system[:] : void#)
	syssz = buf.system.len
	ret = sysctl(mib[:], sys, &syssz, (0 : void#), (0 : size#))
	if ret < 0
		-> ret
	;;

	mib[0] = 1 /* CTL_KERN */
	mib[1] = 10 /* KERN_HOSTNAME */
	nod = (buf.node[:] : void#)
	nodsz = buf.node.len
	ret = sysctl(mib[:], nod, &nodsz, (0 : void#), (0 : size#))
	if ret < 0
		-> ret
	;;

	mib[0] = 1 /* CTL_KERN */
	mib[1] = 2 /* KERN_OSRELEASE */
	rel = (buf.release[:] : void#)
	relsz = buf.release.len
	ret = sysctl(mib[:], rel, &relsz, (0 : void#), (0 : size#))
	if ret < 0
		-> ret
	;;

	mib[0] = 1 /* CTL_KERN */
	mib[1] = 4 /* KERN_VERSION */
	ver = (buf.version[:] : void#)
	versz = buf.version.len
	ret = sysctl(mib[:], ver, &versz, (0 : void#), (0 : size#))
	if ret < 0
		-> ret
	;;

	mib[0] = 6 /* CTL_HW */
	mib[1] = 1 /* HW_MACHINE */
	mach = (buf.machine[:] : void#)
	machsz = buf.machine.len
	ret = sysctl(mib[:], mach, &machsz, (0 : void#), (0 : size#))
	if ret < 0
		-> ret
	;;

	-> 0
}

const sysctl = {mib, old, oldsz, new, newsz
	/* all args already passed through a() or ar  ptrs */
	-> (syscall(Sys__sysctl, \
		(mib : int#), a(mib.len), a(old), a(oldsz), a(new), a(newsz)) : int)
}

const ulock_wait = {op, uaddr, val, timeout
	-> (syscall(Sysulock_wait, a(op), a(uaddr), a(val), a(timeout)) : int)
}

const ulock_wake = {op, uaddr, wakeval
	-> (syscall(Sysulock_wake, a(op), a(uaddr), a(wakeval)) : int)
}

const waitstatus = {st
	if st < 0
		-> `Waitfail st
	;;
	match st & 0o177
	| 0:    -> `Waitexit (st >> 8)
	| 0o177:-> `Waitstop (st >> 8)
	| sig:  -> `Waitsig sig
	;;
}

