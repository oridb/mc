use "cmp"
use "option"

pkg std =
	generic lsearch	: (sl : @t[:], key : @kt, keyfn : (t : @t -> @kt), cmp : (a : @kt, b : @kt -> order) -> option(@idx::(integral,numeric)))
	generic bsearch	: (sl : @t[:], key : @kt, keyfn : (t : @t -> @kt), cmp : (a : @kt, b : @kt -> order) -> option(@idx::(integral,numeric)))
;;

/* linear search over a list of values */
generic lsearch = {sl, key, keyfn, cmp
	for var i = 0; i < sl.len; i++
		match cmp(keyfn(sl[i]), key)
		| `Equal:
			-> `Some i
		| _:
			/* nothing */
		;;
	;;
	-> `None
}

/* binary search over a sorted list of values. */
generic bsearch  = {sl, key, keyfn, cmp
	var hi, lo, mid

	lo = 0
	hi = sl.len - 1

	while lo <= hi
		mid = (hi + lo) / 2
		match cmp(key, keyfn(sl[mid]))
		| `Before:	hi = mid - 1
		| `After:	lo = mid + 1
		| `Equal:	
			-> `Some mid
		;;
	;;
	-> `None
}
		

