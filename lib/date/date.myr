use std
use "types"
use "zoneinfo"

pkg date =
	/* useful constructors */
	const utcnow	: (-> instant)
	const now	: (tz : byte[:] -> instant)
	const tozone	: (d : instant, zone : byte[:]	-> instant)
	const mkdate	: (y : int, m : int, day : int, zone : byte[:]	-> instant)
	const mkdatetime	: (year : int, mon : int, day : int, \
		h : int, m : int, s : int, zone : byte[:]	-> instant)
	const mkinstant	: (tm : std.time, zone : byte[:]	-> instant)

	const localoff	: (tm : std.time -> duration)
	const tzoff	: (tzname : byte[:], tm : std.time	-> duration)
	const isleap	: (d : instant	-> bool)

	/* date differences */
	const add	: (d : instant, dt : duration	-> instant)
	const sub	: (d : instant, dt : duration	-> instant)
	const addperiod	: (d : instant, dt : period	-> instant)
	const subperiod	: (d : instant, dt : period	-> instant)

	const duration	: (a : instant, b : instant	-> duration)

	pkglocal const recalc	: (inst : instant# -> std.time)
;;

const Days400y	= 365*400 + 4*25 - 3
const Days4y	= 365*4 + 1
const DayUsec	= (24*60*60*1_000_000)
const Mdays	= [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

const utcnow = {
	-> mkinstantoff(std.now(), "", 0)
}

const now = {tz : byte[:]
	var tm

	tm = std.now()
	-> mkinstant(tm, tz)
}

const tozone = {d, tz
	-> mkinstant(d.actual, tz)
}

const mkdate = {y, m, d, tz
	-> mkinstant(recalc(&[.year=y, .mon=m, .day=d]), tz)
}

const mkdatetime = {year, mon, day, h, m, s, tz
	var tm

	tm = recalc(&[.year=year, .mon=mon, .day=day,
		.h=h, .m=m, .s=s,])

	match _zoneinfo.findtzoff(tz, tm)
	| `std.Some off:
		-> mkinstantoff(tm, tz, off)
	| `std.None:
		std.fatal("invalid timezone {}\n", tz)
	;;
}

const mkinstant = {tm, tz
	match _zoneinfo.findtzoff(tz, tm)
	| `std.Some o:	-> mkinstantoff(tm, tz, o)
	| `std.None:	std.fatal("no zone named {}\n", tz)
	;;
}

const mkinstantoff = {tm, tz, tzoff
	var j, y, m, d
	var t, e
	var inst

	inst.actual = tm
	/* time zones */
	std.assert(tz.len <= inst._tzbuf.len, "time zone name too long\n")
	std.slcp(inst._tzbuf[:tz.len], tz)
	inst.tzname = inst._tzbuf[:tz.len]
	inst.tzoff = tzoff
	tm += (inst.tzoff : std.time)

	/* break up time */
	t = tm % DayUsec	/* time */
	e = tm / DayUsec	/* epoch day */

	if t < 0
		t += DayUsec
		e -= 1
	;;

	/* microseconds, seconds, minutes, hours */
	inst.us  = (t % 1_000_000 : int)
	t /= 1_000_000
	inst.s = (t % 60 : int)
	t /= 60
	inst.m = (t % 60 : int)
	t /= 60
	inst.h = (t : int)

	/* weekday */
	inst.wday = ((e + 4) % 7 : int)	/* the world started on Thursday */

	/*
	split up year, month, day.

	Implemented according to "Algorithm 199, conversions between calendar 
	date and Julian day number", Robert G. Tantzen, Air Force Missile Development
	Center, Holloman AFB, New Mex.

	Lots of magic. Yer a wizard, 'arry.
	*/
	j = (tm + 2440588 * DayUsec) / DayUsec 
	j -= 1721119

	y = (4 * j - 1) / Days400y
	j = 4 * j - 1 - Days400y * y
	d = j / 4

	j = (4 * d + 3) / Days4y
	d = 4 * d + 3 - Days4y * j
	d = (d + 4) / 4 ;

	m = (5 * d - 3) / 153
	d = 5 * d - 3 - 153 * m
	d = (d + 5) / 5

	y = 100 * y + j
	if m < 10
		m += 3
	else
		m -= 9 
		y++
	;;

	/* there's no year 0 */
	if y <= 0
		y--
	;;
	/* and if j negative, the day and month are also negative */
	if m < 0
		m += 12
	;;
	if d < 0
		d += Mdays[m - 1] 
	;;

	inst.year = (y : int)
	inst.mon = (m : int)
	inst.day = (d : int)
	-> inst
}

const localoff = {tm
	-> tzoff("local", tm)
}

const tzoff = {tz, tm
	match _zoneinfo.findtzoff(tz, tm)
	| `std.Some dt:	-> dt
	| `std.None:	std.fatal("unable to load zoneinfo\n")
	;;
}

const isleap = {d
	-> d.year % 4 == 0 && (d.year % 100 != 0 || d.year % 400 == 0)
}

const add  = {d, dt
	-> mkinstantoff(d.actual + (dt : std.time), d.tzname, d.tzoff)
}

const sub  = {d, dt
	-> mkinstantoff(d.actual - (dt : std.time), d.tzname, d.tzoff)
}

const addperiod = {inst, p
	match p
	| `Year	y:	inst.year += y
	| `Month m:	inst.mon += m
	| `Day	d:	inst.day += d
	| `Hour	h:	inst.h += h
	| `Minute m:	inst.m += m
	| `Second s:	inst.s += s
	;;
	-> mkinstantoff(recalc(&inst), inst.tzname, inst.tzoff)
}

const subperiod = {inst, p
	match p
	| `Year	y:	inst.year -= y
	| `Month m:	inst.mon -= m
	| `Day	d:	inst.day -= d
	| `Hour	h:	inst.h -= h
	| `Minute m:	inst.m -= m
	| `Second s:	inst.s -= s
	;;
	-> mkinstantoff(recalc(&inst), inst.tzname, inst.tzoff)
}

const duration = {a, b
	-> (b.actual - a.actual : duration)
}

const recalc = {inst
	var c, ya, j, tm
	var y, m, d


	if inst.mon > 2
		m = (inst.mon - 3 : std.time)
		y = (inst.year : std.time)
	else
		m = (inst.mon + 9 : std.time)
		y = (inst.year - 1 : std.time)
	;;
	d = (inst.day : std.time)

	c = y / 100
	ya = y - 100 * c
	j = c * Days400y / 4 + \
		Days4y * ya / 4 + \
		(153 * m + 2)/5 + d - \
		719469
	tm = j * DayUsec
	tm += (inst.h : std.time) * 3600*1_000_000
	tm += (inst.m : std.time) * 60*1_000_000
	tm += (inst.s : std.time) * 1_000_000
	tm += (inst.us : std.time)
	-> tm
}

